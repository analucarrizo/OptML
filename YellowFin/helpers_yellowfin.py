# -*- coding: utf-8 -*-
"""helpers_yellowfin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kS1cHEeacGRCezqybsCGMwSyYgpbgeDy
"""

from google.colab import drive
drive.mount('/content/drive')

# !cp drive/MyDrive/OptML/YellowFin/yellowfin.py .

from yellowfin import YFOptimizer
from model import *
from helpers import *

from sklearn.model_selection import KFold
import sklearn
from sklearn.datasets import fetch_openml
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import torch
import torch.nn as nn
import torchvision
from torch.nn import functional as F
import numpy as np
import time 
import itertools
from tqdm.notebook import tqdm
import torchvision.datasets as datasets
from torch.optim import Adam

torch.manual_seed(42)

def get_yellowfin(model, config):
  yellowfin_optimizer = YFOptimizer(model.parameters(),
                        lr = config["lr"],
                        weight_decay = config["wd"],
                        mu = config["mu"])
  return yellowfin_optimizer

def hyperparameters_yellowfin(mnist_train, model, params, device):
  start_time = time.time()
  keys, values = zip(*params.items())
  permutations_dict = [dict(zip(keys, v)) for v in itertools.product(*values)]

  opt_acc = 0.0
  opt_config = {}

  for config in tqdm(permutations_dict):
    print('-----------------------')
    print("Current Parameters: ", config)
    acc = cross_validation_yellowfin(mnist_train, model, config, get_yellowfin(model, config), device)

    if acc > opt_acc:
      opt_acc = acc
      opt_config = config
  
  end_time = time.time()
  print(f" Best Accuracy: {opt_acc}, with parameters {opt_config}")
  print(f" Runtime: {((end_time - start_time)/60):.4} minutes")
  return opt_config, opt_acc

def cross_validation_yellowfin(mnist_train, model, params, yellowfin, device, IA_activate = False):
  kfold = KFold(n_splits = params["folds"], shuffle = True)
  results = {}

  for fold, (train_idx, val_idx) in enumerate(kfold.split(mnist_train)):
    print(f"---------------Fold {fold+1}--------------")

    train_subsampler = torch.utils.data.SubsetRandomSampler(train_idx)
    val_subsampler = torch.utils.data.SubsetRandomSampler(val_idx)

    train_loader = torch.utils.data.DataLoader(mnist_train, 
                                               batch_size=params["batch_size"],
                                               sampler = train_subsampler,
                                               pin_memory=torch.cuda.is_available())
    val_loader = torch.utils.data.DataLoader(mnist_train, 
                                             batch_size=params["batch_size"],
                                             sampler = val_subsampler,
                                             pin_memory = torch.cuda.is_available())

    model.apply(reset_weights)

    val_acc = 0.0
    for epoch in range(params["epochs"]):
      train(model, train_loader, params["criterion"](), yellowfin, device, params["view_every"])
      curr_acc = (test(model, val_loader, device)) * 100.0
      val_acc = curr_acc

      print(f"epoch {epoch + 1}/{params['epochs']}, Accuracy: {curr_acc:.4}")
    
    results[fold] = curr_acc

  # Print fold results
  print('--------------------------------')
  print(f'K-FOLD CROSS VALIDATION RESULTS FOR {params["folds"]} FOLDS')
  print('--------------------------------')
  
  sum = 0.0
  for fold, value in results.items():
    print(f"Fold {fold}: {value} %")
    sum += value
  
  avg_acc = sum/len(results.items())
  print(f"Average: {avg_acc:.4} %")
  print("-----------")
  
  return avg_acc

def run_best_model_yellowfin(mnist_train, mnist_test, model, config, device):
  train_loader = torch.utils.data.DataLoader(mnist_train, 
                                             batch_size=config["batch_size"], 
                                             shuffle=True, 
                                             pin_memory=torch.cuda.is_available())
  test_loader = torch.utils.data.DataLoader(mnist_test, 
                                            batch_size=config["batch_size"], 
                                            shuffle=True, 
                                            pin_memory = torch.cuda.is_available())
  
  start_time = time.time()
  nb_epochs = config["epochs"]
  nb_folds = config["folds"]
  accs = [0]*nb_epochs

  for fold in range(nb_folds):
    model.to(device)

    batch_size = config["batch_size"]
    criterion = config["criterion"]()
    optimizer = get_yellowfin(model, config)
    
    print(f"------ FOLD {fold + 1} -------")
    
    for epoch in range(nb_epochs):
      train(model, train_loader, criterion, optimizer, device, config["view_every"])
      acc = test(model, test_loader, device)

      accs[epoch] += acc

      print(f"Epoch {epoch} - accuracy: {acc:.4}")

  for i in range(len(accs)):
    accs[i] /= nb_folds

  print(f"----- {((time.time() - start_time)/60):.4} minutes")
  return accs